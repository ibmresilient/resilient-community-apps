<!--
    DO NOT MANUALLY EDIT THIS FILE
    THIS FILE IS AUTOMATICALLY GENERATED WITH resilient-sdk codegen
    Generated with resilient-sdk v49.0.4368
-->

# Playbook - REST API (PB)

### API Name
`rest_api_pb`

### Status
`enabled`

### Activation Type
`manual`

### Object Type
`artifact`

### Description
This is a general-purpose function to call any REST API or other HTTP service.


---
## Function - REST API

### API Name
`rest_api`

### Output Name
`rest_response`

### Message Destination
`fn_rest_api`

### Function-Input Script
```python
# ALLOWED_STATUS_CODE
# -------------------
# Any status code below 300 is allowed by default. If you specify codes above 300, they are
# exempted from raising an exception and thereby returns the endpoint response. Multiple
# status codes can be specified as a string in a command separated fashion.
#    
#    Example:
#    --------
#     inputs.rest_api_allowed_status_codes = "305, 400, 404, 500"
#
#
# SECRETS
# -------
# For sensitive information that may be included in the rest_header, rest_url, rest_body, or 
# rest_cookies, you can substitute values from the app.conf. To do so simply create a Key
# and a value pair in app.conf and then directly reference the key here using
# double-curly brace.
#
#    Example:
#    --------
#      headers = """
#      Content-Type: application/json
#      X-Frooble: Baz
#      Authorization: {{auth_header}}
#      """
#
#
# INPUT FORMAT
# ------------
# rest_api_url, rest_api_method and rest_api_verify are mandatory fields.
# rest_api_headers, rest_api_cookies, rest_api_body can accept 2 different formats.
#
# 1. New-line separated (Legacy)
#    ---------------------------
#
#    This format allows for specifying inputs as key-value pairs, separated
#    by a new line. It let's us create quick and easy inputs that is properly
#    formatted for the request. The primary purpose of this format is to retain
#    backwards compatibility.
#
#    Note:  This format does not support complex data structures such as lists
#    -----  or nested Key-value pairs.
#
#    Example:
#    -------- 
#      body = """
#      name : user1
#      password : p@ssword1
#      role : admin
#      """             
# 
#      headers = """
#      Content-Type: application/json
#      X-Frooble: Baz
#      Authorization: {{auth_header}}
#
#
#
# 2. JSON format:
#    ------------
#
#    Standard json file format. Supports complex data structures such as lists
#    or nested Key-value pairs.
#
#    Example:
#    --------
#      body = """
#      "name" : "user1",
#      "password" : "p@ssword1",
#      "role" : "admin",
#      "content" : { "site_url" : "www.example.com", "users" : ["user1", "user2"] }
#      """      
#
#
#    Hint:
#    -----
#
#    An easier way to feed inputs to the above mentioned fields would be using
#    python dictionaries. While the inputs don't directly support dict, the in-built 
#    json package can be used to convert a python dict to json string.
#
#    Example:
#    --------
#      import json
#     
#      body = {
#       "name"     : "user1",
#       "password" : "p@ssword1",
#       "role"     : "admin",
#       "content"  : { 
#          "site_url" : "www.example.com",
#          "users"    : ["user1", "user2"]
#          }
#      }
#     
#     inputs.rest_api_body = json.dumps(body) # this converts the dict to a json string
#
#
#
# REUSABILITY
# -----------
# Multiple endpoints can be called from within a playbook. Simply duplicate this function
# and modify the pre-processing script as per the endpoint, and the request to be made.
#
#
# """

method = "POST"

url = "https://www.example.com"

header = """
Authorization : {{auth_header}}
Content-type  : application/json
"""

body = """
"displayName"  : "Library Assist",
"mailEnabled"  : true,
"mailNickname" : "library",
"securityEnabled" : true,
"groupTypes": ["Unified"]
"""

cookie  = None
verify  = True
timeout = 60
allowed_status_code = "305, 400, 404, 500"

inputs.rest_api_url     = url                          # Endpoint url
inputs.rest_api_headers = header if header else None   # Request headers used for Authorization
inputs.rest_api_cookies = cookie if cookie else None   # Cookies for request
inputs.rest_api_body    = body if body else None       # Request body
inputs.rest_api_verify  = verify if verify else True   # (Boolean) indicates whether to verify SSL certificates.
inputs.rest_api_timeout = timeout if timeout else 600  # Request timeout
inputs.rest_api_allowed_status_codes = allowed_status_code if allowed_status_code else "200" # Status codes in a comma separated fashion, Anything less than a status code 300 is allowed by default
inputs.rest_api_method  = method if method and method in ["GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS"] else "GET" #REST methods: GET, HEAD, POST, PUT, DELETE and OPTIONS

```

---

## Local script - Process REST Response

### Description
Script to process Endpoint response.

### Script Type
`Local script`

### Objet Type
`artifact`

### Script Content
```python
'''
results = {
  "ok"      : response.ok,
  "url"     : response.url,
  "reason"  : response.reason,
  "cookies" : dedup_dict(response.cookies),
  "headers" : dedup_dict(response.headers),
  "elapsed" : int(response.elapsed.total_seconds() * 1000.0),
  "text"    : response.text,
  "json"    : response_json,
  "links"   : response.links,
  "status_code": response.status_code,
  "apparent_encoding": response.apparent_encoding,
}
'''

result = playbook.functions.results.rest_response

if not result.success:
  incident.addNote(helper.createRichText(result.reason))

else:
  response_text = result.content.get("text")
  if artifact.description:
    artifact.description = u"{}\n\n{}".format(artifact.description.content, response_text)
  else:
    artifact.description = response_text 

```

---
