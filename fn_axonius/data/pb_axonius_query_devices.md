<!--
    DO NOT MANUALLY EDIT THIS FILE
    THIS FILE IS AUTOMATICALLY GENERATED WITH resilient-sdk codegen
    Generated with resilient-sdk v51.0.1.0.695
-->

# Playbook - Axonius: Query Devices

### API Name
`axonius_query_devices`

### Status
`enabled`

### Activation Type
`Manual`

### Activation Conditions
`-`

### Activation Form Elements
| Input Field Label | API Name | Element Type | Tooltip | Requirement |
| ----------------- | -------- | ------------ | ------- | ----------- |
| Attachment Name | `axonius_attachment_name` | text | Optional attachment name if Attachment is selected in Results Output. | Optional |
| Limit | `axonius_device_limit` | number | Limit the number of devices returned from query. Default is one. | Optional |
| Query String | `axonius_query_string` | textarea | Axonius Query Language (AQL) string used to query devices. | Optional |
| Results Output | `axonius_results_output` | select | Output query results to the Axonius Devices data table or to a note. | Always |
| Saved Query Name | `axonius_saved_query_name` | text | Saved Query Name in Axonius to use to query devices. | Optional |

### Object Type
`incident`

### Description
Query Axonius using the user specified AQL query string or a saved query name in Axonius.  Optionally populate the devices returned in the Axonius Devices data table, write to a note or to an attachment.


---
## Function - Axonius: Get Device by Query

### API Name
`axonius_get_device_by_query`

### Output Name
`get_device_results`

### Message Destination
`fn_axonius`

### Function-Input Script
```python
from json import (dumps)

# Limit number of devices populated in the Axonius Devices data table.
# Change this default value if you want more results populated in the data table.
DEFAULT_DATA_TABLE_LIMIT = 100

# Fill a default query string or saved query name in case user does not provide inputs.
DEFAULT_QUERY_STRING = None
DEFAULT_QUERY_NAME = None

if getattr(playbook.inputs, "axonius_query_string", None):
  inputs.axonius_query_string = playbook.inputs.axonius_query_string.get("content")
else:
  inputs.axonius_query_string = DEFAULT_QUERY_STRING if DEFAULT_QUERY_STRING else None
  
if getattr(playbook.inputs, "axonius_saved_query_name", None):
  inputs.axonius_saved_query_name = getattr(playbook.inputs, "axonius_saved_query_name", None)
else:
  inputs.axonius_saved_query_name = DEFAULT_QUERY_NAME if DEFAULT_QUERY_NAME else None
  
if not inputs.axonius_query_string and not inputs.axonius_saved_query_name:
  helper.fail("A query string or a saved query_name must be specified")

inputs.axonius_write_attachment = False
inputs.axonius_incident_id = incident.id
inputs.axonius_task_id = None
inputs.axonius_device_limit = getattr(playbook.inputs, "axonius_device_limit", None) if getattr(playbook.inputs, "axonius_device_limit", None) else 1
  
# Set different fields to retrieve from Axonius depending on if writing to a note 
# or the Axonius Devices data table.
if getattr(playbook.inputs, "axonius_results_output", None) == "Note":
  # These are the default fields when writing device data to a note or attachment.
  # Edit these fields below to get different fields returned from the Axonius device query.
  field_names = ["specific_data.data.network_interfaces.ips_preferred", 
                 "specific_data.data.name",
                 "specific_data.data.hostname_preferred",
                 "specific_data.data.owner",
                 "specific_data.data.last_used_users_mail_association",
                 "specific_data.data.os.type_distribution",
                 "specific_data.data.last_used_users",
                 "specific_data.data.last_used_users_departments_association",
                 "specific_data.data.hard_drives.encryption_status",
                 "specific_data.data.device_disabled",
                 "specific_data.data.network_interfaces.security_level_preferred",
                 "specific_data.data.network_interfaces.region_preferred",
                 "specific_data.data.network_interfaces.country_preferred",
                 "labels"]
elif getattr(playbook.inputs, "axonius_results_output", None) == "Attachment":
  # These are the default fields when writing results to an attachment.
  field_names = ["specific_data.data.network_interfaces.ips_preferred", 
                 "specific_data.data.name",
                 "specific_data.data.hostname_preferred",
                 "specific_data.data.owner",
                 "specific_data.data.last_used_users_mail_association",
                 "specific_data.data.os.type_distribution",
                 "specific_data.data.last_used_users",
                 "specific_data.data.last_used_users_departments_association",
                 "specific_data.data.hard_drives.encryption_status",
                 "specific_data.data.device_disabled",
                 "specific_data.data.network_interfaces.security_level_preferred",
                 "specific_data.data.network_interfaces.region_preferred",
                 "specific_data.data.network_interfaces.country_preferred",
                 "labels"]
  inputs.axonius_write_attachment = True
  query_string = inputs.axonius_saved_query_name if inputs.axonius_saved_query_name else inputs.axonius_query_string
  inputs.axonius_attachment_name = playbook.inputs.axonius_attachment_name if getattr(playbook.inputs, "axonius_attachment_name", None) else f"Axonius-Query-{query_string}.json"
else:
  # These are the default fields used for populating the Axonius Devices data table.
  # If changing the columns of the data table, update the required fields here and update
  # the Global Script "Axonius: Populate Devices Data Table" to fill in the the columns. 
  field_names = ["specific_data.data.network_interfaces.ips_preferred", 
                 "specific_data.data.name",
                 "specific_data.data.hostname_preferred",
                 "specific_data.data.owner",
                 "specific_data.data.last_used_users_mail_association",
                 "specific_data.data.os.type_distribution",
                 "specific_data.data.last_used_users",
                 "specific_data.data.last_used_users_departments_association",
                 "specific_data.data.hard_drives.encryption_status",
                 "specific_data.data.device_disabled",
                 "specific_data.data.network_interfaces.security_level_preferred",
                 "specific_data.data.network_interfaces.region_preferred",
                 "specific_data.data.network_interfaces.country_preferred",
                 "labels"]
  # If writing to the data table, use a hard limit so that the scripting engine does not fail processing too many results.
  inputs.axonius_device_limit = DEFAULT_DATA_TABLE_LIMIT if inputs.axonius_device_limit > DEFAULT_DATA_TABLE_LIMIT else inputs.axonius_device_limit
  
inputs.axonius_field_name_list = dumps(field_names)



```

---

## Global script - Axonius: Populate Devices Data Table

### Description
Add the results returned from querying devices to the Axonius Devices data table.

### Script Type
`Global script`

### Object Type
`incident`

### Script Content
```python
from datetime import datetime

DEVICE_URL = "{endpoint_url}/assets/devices/{axonius_id}/asset-profile/all"

def get_non_null_item_from_list(item_list):
    # Return the first non-null item from the list, if any.
    if isinstance(item_list, list):
        non_null_item = next((item for item in item_list if item is not None), None)
        return non_null_item
    elif isinstance(item_list, str):
        return item_list
    else:
        return None

def unique_list_items_to_csv_string(item_list):
    # Return a comma separated list of unique strings from a list of strings.
    if isinstance(item_list, list):
        unique_items = list(set(item_list))
        return ", ".join(unique_items)
    elif isinstance(item_list, str):
        return item_list
    else:
        return None
        
results = playbook.functions.results.get_device_results

inputs = results.get("inputs", None)
query_string = inputs.get("axonius_query_string", None) if inputs else None
saved_query_name = inputs.get("axonius_saved_query_name", None) if inputs else None
axonius_device_limit = inputs.get("axonius_device_limit") if inputs else None
inputs_string = ""
if query_string:
  inputs_string = f"{inputs_string}<br><b>Query String:</b> {query_string}"
if saved_query_name:
  inputs_string = f"{inputs_string}<br><b>Saved Query Name:</b> {saved_query_name}"
inputs_string = f"{inputs_string}<br><b>Limit:</b> {axonius_device_limit}"

if results.get("success", False):
  content = results.get("content", {})
  if content:
    assets_list = content.get("assets", [])
    if assets_list:
      for asset in assets_list:
        asset_row = incident.addRow("axonius_devices_dt")
        asset_row.axonius_query_date = datetime.now()
        asset_row.axonius_id = asset.get("internal_axon_id", None)
        if content.get("endpoint_url"):
          device_url = DEVICE_URL.format(endpoint_url=content.get("endpoint_url"), axonius_id=asset.get("internal_axon_id", None))
          asset_row.axonius_link = "<a href='{0}'>Link</a>".format(device_url)
        asset_row.axonius_ip       = unique_list_items_to_csv_string(asset.get("specific_data.data.network_interfaces.ips_preferred", None))
        asset_row.axonius_name     = get_non_null_item_from_list(asset.get("specific_data.data.name", None))
        asset_row.axonius_hostname = get_non_null_item_from_list(asset.get("specific_data.data.hostname_preferred", None))
        asset_row.axonius_owner = unique_list_items_to_csv_string(asset.get("specific_data.data.owner", None))
        asset_row.axonius_email = unique_list_items_to_csv_string(asset.get("specific_data.data.last_used_users_mail_association", None))
        asset_row.axonius_os_type_distribution = unique_list_items_to_csv_string(asset.get("specific_data.data.os.type_distribution", None))
        asset_row.axonius_last_used_users      = unique_list_items_to_csv_string(asset.get("specific_data.data.last_used_users", None))
        asset_row.axonius_last_used_users_dept = unique_list_items_to_csv_string(asset.get("specific_data.data.last_used_users_departments_association", None))
        asset_row.axonius_hard_drives_encryption_status = get_non_null_item_from_list(asset.get("specific_data.data.hard_drives.encryption_status", None))
        asset_row.axonius_device_disabled = get_non_null_item_from_list(asset.get("specific_data.data.device_disabled", None))
        asset_row.axonius_security_level  = get_non_null_item_from_list(asset.get("specific_data.data.network_interfaces.security_level_preferred", None))
        asset_row.axonius_region          = get_non_null_item_from_list(asset.get("specific_data.data.network_interfaces.region_preferred", None))
        asset_row.axonius_country         = get_non_null_item_from_list(asset.get("specific_data.data.network_interfaces.country_preferred", None))
        asset_row.axonius_tags = unique_list_items_to_csv_string(asset.get("labels", None))
      num_assets = len(assets_list)
      note_text = f"<b>Axonius: Populate Devices Data Table:</b> Added <b>{num_assets}</b> asset to the Axonius Devices data table {inputs_string}"
    else:
      note_text = f"<b>Axonius: Populate Devices Data Table:</b> No device asset found matching inputs: {inputs_string}"  
  else:
    note_text = f"Axonius: Populate Devices Data Table: No asset found (no content): {inputs_string}"
else:
  reason = results.get("reason", None)
  note_text = f"Axonius: Populate Devices Data Table: Failed function to get asset: {inputs_string}<br> Reason = {reason}"
  
incident.addNote(note_text)
```

---
## Global script - Convert JSON to rich text v1.3

### Description
This script converts a json object into a hierarchical display of rich text and adds the rich text to an incident's rich text (custom) field or an incident note. A workflow property is used to share the json to convert and identify parameters used on how to perform the conversion.
Typically, a function will create workflow property and this script will run after that function to perform the conversion.

Features:

* Display the hierarchical nature of json, presenting the json keys (sorted if specified) as bold labels
* Provide links to found URLs
* Create either an incident note or add results to an incident (custom) rich text field.

### Script Type
`Global script`

### Object Type
`incident`

### Script Content
```python
# (c) Copyright IBM Corp. 2010, 2023. All Rights Reserved.
VERSION = 1.3
"""
  This script converts a json object into a hierarchical display of rich text and adds the rich text to an incident's rich text (custom) field or an incident note.
  A workflow property is used to define the json to convert and identify parameters used on how to perform the conversion.
  Typically, a function will create workflow property and this script will run after that function to perform the conversion.
  Features:
    * Display the hierarchical nature of json, presenting the json keys as bold labels
    * Provide links to found URLs
    * Create either an incident note or add results to an incident (custom) rich text field.
  
  In order to use this script, define a workflow property called: convert_json_to_rich_text, to define the json and parameters to use for the conversion.
  Workflow properties can be added using a command similar to this:
  workflow.addProperty('convert_json_to_rich_text', {
    "version": 1.3,
    "header": "Artifact scan results for: {}".format(artifact.value),
    "padding": 10,
    "separator": u"<br />",
    "sort": True,
    "json": results.content,
    "json_omit_list": ["omit"],
    "incident_field": None
  })
  
  Format of workflow.property.convert_json_to_rich_text:
  { 
    "version": 1.3, [this is for future compatibility]
    "header": str, [header line to add to converted json produced or None. Ex: Results from scanning artifact: xxx. The header may contain rich text tags]
    "padding": 10, [padding for nested json elements, or defaults to 10]
    "separator": u"<br />"|list such as ['<span>','</span>'], [html separator between json keys and lists or defaults to html break: '<br />'. 
                                                If a list, then the data is brackets by the pair specified]
    "sort": True|False, [sort the json keys at each level when displayed]
    "json": json, [required json to convert]
    "json_omit_list": [list of json keys to exclude or None]
    "incident_field": "<incident_field>" [indicates a builtin rich text incident field, such as 'description' 
                                          or a custom rich text field in the format: 'properties.<field>'. default: create an incident note]
  }

  For playbooks, use playbook.addProperty() with the same format as workflow.addProperty()

  Playbooks can also use playbook.functions.results.convert_json_to_rich_text using the standard function output which contains the 'content' json element.
  When using playbook.functions.results.convert_json_to_rich_text with standard function results, all the defaults for padding, separator, etc. are used.
"""

import re

# needed for python 3
try:
    unicode("abc") # fails in py3
    py2 = True
except:
    unicode = str
    py2 = False


rc = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+#\?]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')

class ConvertJson:
    """Class to hold the conversion parameters and perform the conversion"""

    def __init__(self, omit_keys=[], padding=10, separator=u"<br />", sort_keys=False):
        self.omit_keys = omit_keys
        self.padding = padding
        self.separator = separator
        self.sort_keys = sort_keys


    def format_link(self, item):
        """[summary]
          Find embedded urls (http(s)) and add html anchor tags to display as links
          Args:
              item ([string])

          Returns:
              [str]: None|original text if no links|text with html links
        """
        formatted_item = item
        if py2:
            num_type = bool(item and isinstance(item, (int, long, bool, float)))
        else:
            num_type = bool(item and isinstance(item, (int, bool, float)))

        if item and not num_type:
            list = rc.findall(item)
            if list:
                for link in list:
                    formatted_item = formatted_item.replace(link, u"<a target='blank' href='{0}'>{0}</a>".format(link))

        return formatted_item

    def expand_list(self, list_value, is_list=False):
        """[summary]
          convert items to html, adding indents to nested dictionaries.
          Args:
              list_value ([dict|list]): json element

          Returns:
              [str]: html converted code
        """
        if not isinstance(list_value, list):
            return self.format_link(list_value)
        elif not list_value:
            return u"None<br>"

        try:
            items_list = []  # this will ensure list starts on second line of key label
            for item in list_value:
                if isinstance(item, dict):
                    result = self.convert_json_to_rich_text(item)
                    if is_list:
                        items_list.append(u"<li>{}</li>".format(result))
                    else:
                        items_list.append(result)
                elif isinstance(item, list):
                    items_list.append(self.expand_list(item, is_list=True))
                elif is_list:
                    items_list.append(u"<li>{}</li>".format(self.format_link(unicode(item))))
                else:
                    items_list.append(self.format_link(unicode(item)))

            expand_list_result = self.add_separator(self.separator if not is_list else u"",
                                                    items_list,
                                                    is_list=is_list)

            if is_list:
                return u"<ul>{}</ul>".format(expand_list_result)
            else:
                return u"<div style='padding:5px'>{}</div>".format(expand_list_result)
        except Exception as err:
            return str(err)

    def convert_json_to_rich_text(self, sub_dict):
        """[summary]
          Walk dictionary tree and convert to html for better display
          Args:
              sub_dict ([type]): [description]

          Returns:
              [type]: [description]
        """
        notes = []
        if sub_dict and isinstance(sub_dict, (list, dict)):
            if isinstance(sub_dict, list):
                expanded_list = self.expand_list(sub_dict, is_list=True)
                notes.append(self.add_separator(self.separator, expanded_list))
            else:
                keys = sorted (sub_dict.keys()) if self.sort_keys else sub_dict.keys()

                for key in keys:
                    if key not in self.omit_keys:
                        value = sub_dict[key]
                        is_list = isinstance(value, list)
                        item_list = [u"<strong>{0}</strong>: ".format(key)]
                        if isinstance(value, dict):
                            convert_result = self.convert_json_to_rich_text(value)
                            if convert_result:
                                item_list.append(u"<div style='padding:{}px'>{}</div>".format(self.padding, convert_result))
                            else:
                                item_list.append(u"None<br>")
                        else:
                            item_list.append(self.expand_list(value, is_list=is_list))

                        notes.append(self.add_separator(self.separator, u"".join(make_unicode(v) for v in item_list), is_list=is_list))

        result_notes = u"".join(notes)
        if isinstance(self.separator, list):
            return result_notes
        else:
            return result_notes.replace(
                u"</div>{0}".format(self.separator), u"</div>").replace(
                u"{0}</div>".format(self.separator), u"</div>"
            )  # tighten up result

    def add_separator(self, separator, items, is_list=False):
        """
        apply the separator to the data
        :param separator: None, str or list such as ['<span>', '</span>']
        :param items: str or list to add separator
        :return: text with separator applied
        """
        _items = items

        if not _items:
            return "<br>"

        if not isinstance(_items, list):
            _items = [_items]

        if isinstance(separator, list):
            return u"".join([u"{}{}{}".format(separator[0], item, separator[1]) for item in _items])

        return u"{}{}".format(separator.join(_items), separator if not is_list else u"")

def make_unicode(value):
    if value is None:
        return 'None'

    return unicode(value)

def get_results(property_name):
    if playbook and playbook.functions.results[property_name] is not None:
        return playbook.functions.results[property_name]
    elif playbook and playbook.properties[property_name] is not None:
        return playbook.properties[property_name]
    elif workflow and workflow.properties[property_name] is not None:
        return workflow.properties[property_name]

    return None

def get_properties(property_name):
    """
    Logic to collect the json and parameters from a workflow property.
    Args:
      property_name: workflow property to reference
    Returns:
      padding, separator, header, json_omit_list, incident_field, json, sort_keys
    """
    result_properties = get_results(property_name)
    if not result_properties:
        helper.fail("Playbook/workflow property not found: {}".format(property_name))

    padding = int(result_properties.get("padding", 10))
    separator = result_properties.get("separator", u"<br />")
    if isinstance(separator, list) and len(separator) != 2:
        helper.fail("list of separators should be specified as a pair such as ['<div>', '</div>']: {}".format(separator))

    header = result_properties.get("header")
    sort_keys = bool(result_properties.get("sort", False))
    json_omit_list = result_properties.get("json_omit_list")
    if not json_omit_list:
        json_omit_list = []
    incident_field = result_properties.get("incident_field")
    
    # workflow formatted content is 'json'. Standard functions is 'content'
    json = result_properties.get("json") if result_properties.get("json") else result_properties.get("content")
    json_err = None
    # is there an issue we need handle now?
    if not json and \
        result_properties.get("success") == False and result_properties.get("reason"):
        json_err = result_properties.get("reason")
    
    return padding, separator, header, json_omit_list, incident_field, json, json_err, sort_keys


## S T A R T
padding, separator, header, json_omit_list, incident_field, json, json_err, sort_keys = get_properties('convert_json_to_rich_text')
if json_err:
    result = "Result error: {}".format(json_err)
else:
    if header:
        if isinstance(separator, list):
            hdr = u"{0}{1}{2}".format(separator[0], header, separator[1])
        else:
            hdr = u"{0}{1}".format(header, separator)
    else:
        hdr = u""

    convert = ConvertJson(omit_keys=json_omit_list, padding=padding, separator=separator, sort_keys=sort_keys)
    converted_json = convert.convert_json_to_rich_text(json)
    result = u"{}{}".format(hdr, converted_json if converted_json else "\nNone")

rich_text_note = helper.createRichText(result)
if incident_field:
    incident[incident_field] = rich_text_note
else:
    incident.addNote(rich_text_note)

```

---
## Local script - Axonius: Write JSON results to note

### Description
Write the JSON query results to a note.

### Script Type
`Local script`

### Object Type
`incident`

### Script Content
```python
results = playbook.functions.results.get_device_results
inputs = results.get("inputs", None)

device_limit = inputs.get("axonius_device_limit", None)
query_string = inputs.get("axonius_query_string", None) if inputs else None
saved_query_name = inputs.get("axonius_saved_query_name", None) if inputs else None
inputs_string = ""
if query_string:
  inputs_string = f"{inputs_string}<br><b>Query String:</b> {query_string}"
if saved_query_name:
  inputs_string = f"{inputs_string}<br><b>Saved Query Name:</b> {saved_query_name}"
inputs_string = f"{inputs_string}<br><b>Limit:</b> {device_limit}"
content = results.get("content", {})
device_count = content.get("device_count", [])
header = f"<b>Axonius: Query Devices:</b> {device_count} devices returned{inputs_string}<br>"

json_note = {
              "version": "1.3",
              "header": header, 
              "json": results.content,
              "sort": False
            }
playbook.addProperty('convert_json_to_rich_text', json_note)
```

---
## Local script - Axonius: Write Attachment results to a note

### Description
Write query results to attachment 

### Script Type
`Local script`

### Object Type
`incident`

### Script Content
```python
results = playbook.functions.results.get_device_results
inputs = results.get("inputs", None)
axonius_device_limit = inputs.get("axonius_device_limit", None)
query_string = inputs.get("axonius_query_string", None) if inputs else None
saved_query_name = inputs.get("axonius_saved_query_name", None) if inputs else None
inputs_string = ""
if query_string:
  inputs_string = f"{inputs_string}<br><b>Query String:</b> {query_string}"
if saved_query_name:
  inputs_string = f"{inputs_string}<br><b>Saved Query Name:</b> {saved_query_name}"
inputs_string = f"{inputs_string}<br><b>Limit:</b> {axonius_device_limit}"

if results.get("success", False):
  content = results.get("content", None)
  if content:
    device_count = content.get("device_count", [])
    note_text = f"<b>Axonius: Query Devices:</b> {device_count} devices returned{inputs_string}<br>"
    attachment_name = content.get("attachment_name", None)
    note_text = f"{note_text}<br>Written to attachment: <b>{attachment_name}</b>."
  else:
    note_text = f"<b>Axonius: Query Devices:</b> attachment was not written (no content).{inputs_string}"
else:
    reason = results.get("reason", None)
    note_text = f"<b>Axonius: Query Devices:</b> attachment was not written:{inputs_string}<br>Reason: {reason}."
    
incident.addNote(note_text)
```

---

