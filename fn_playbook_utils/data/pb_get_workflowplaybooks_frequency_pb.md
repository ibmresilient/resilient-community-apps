<!--
    DO NOT MANUALLY EDIT THIS FILE
    THIS FILE IS AUTOMATICALLY GENERATED WITH resilient-sdk codegen
    Generated with resilient-sdk v50.0.151
-->

# Playbook - PBUtil: Get workflow/playbooks frequency (PB)

### API Name
`pb_get_workflowplaybooks_frequency_pb`

### Status
`enabled`

### Activation Type
`Manual`

### Activation Conditions
`-`

### Activation Form Elements
| Input Field Label | API Name | Element Type | Tooltip | Requirement |
| ----------------- | -------- | ------------ | ------- | ----------- |
| Max incident date | `pb_max_incident_date` | datepicker | - | Optional |
| Max incident Id | `pb_max_incident_id` | number | Last incident to search | Optional |
| Min incident date | `pb_min_incident_date` | datepicker | - | Optional |
| Min incident Id | `pb_min_incident_id` | number | - | Optional |

### Object Type
`incident`

### Description
Provide a summary of workflows and playbooks runs across a range of incidents


---
## Function - PB: Get Workflow Data

### API Name
`pb_get_workflow_data`

### Output Name
`workflow_data`

### Message Destination
`fn_playbook_utils`

### Function-Input Script
```python
if not (playbook.inputs.pb_max_incident_id or playbook.inputs.pb_min_incident_id or playbook.inputs.pb_min_incident_date or playbook.inputs.pb_max_incident_date):
  inputs.pb_max_incident_id = incident.id
  inputs.pb_min_incident_id = incident.id
else:
  inputs.pb_max_incident_id = playbook.inputs.pb_max_incident_id
  inputs.pb_min_incident_id = playbook.inputs.pb_min_incident_id
  
inputs.pb_min_incident_date = playbook.inputs.pb_min_incident_date
inputs.pb_max_incident_date = playbook.inputs.pb_max_incident_date

inputs.pb_object_name = inputs.pb_object_type = None

```

---
## Function - PB: Get Playbook Data

### API Name
`pb_get_playbook_data`

### Output Name
`playbook_data`

### Message Destination
`fn_playbook_utils`

### Function-Input Script
```python
if not (playbook.inputs.pb_max_incident_id or playbook.inputs.pb_min_incident_id or playbook.inputs.pb_min_incident_date or playbook.inputs.pb_max_incident_date):
  inputs.pb_max_incident_id = incident.id
  inputs.pb_min_incident_id = incident.id
else:
  inputs.pb_max_incident_id = playbook.inputs.pb_max_incident_id
  inputs.pb_min_incident_id = playbook.inputs.pb_min_incident_id
  
inputs.pb_min_incident_date = playbook.inputs.pb_min_incident_date
inputs.pb_max_incident_date = playbook.inputs.pb_max_incident_date

inputs.pb_object_name = inputs.pb_object_type = None

```

---

## Local script - Get Workflow Data Post-Process Script

### Description


### Script Type
`Local script`

### Object Type
`incident`

### Script Content
```python
INCIDENT_URL = "<a href='/#incidents/{0}'>{0}</a>"
OBJECT_TYPES = ['incident', 'task', 'artifact', 'attachment', 'note', 'milestone']
wf_stats = {}
object_stats = { object: {} for object in OBJECT_TYPES }


def update_workflow_stats(workflow_name, workflow_id, workflow_type):
  """[tracking frequency of workflows by workflow id]

  Args:
    workflow_name ([str]): [workflow name]
    workflow_id ([int]): [id of workflow]
    workflow_type ([str]): [artifact, incident, task, or attachment]
  """
  if workflow_id not in wf_stats:
    wf_stats[workflow_id] = {
      "name": workflow_name,
      "type": workflow_type,
      "workflows": 0
    }

  wf_stats[workflow_id]['workflows'] += 1

def update_object_stats(workflow_name, object_name, object_type):
  """[track what workflows are run on a given attachment, task or artifact]

  Args:
    workflow_name ([str]): [workflow name]
    object_name ([str]): [value of artifact or name to attachment/task]
    object_type ([str]): [artifact, incident, task, or attachment]
  """
  if object_name not in object_stats.get(object_type, []):
    if object_type not in object_stats:
      object_stats[object_type] = {}
    object_stats[object_type][object_name] = []

  object_stats[object_type][object_name].append(workflow_name)

def sort_wf_stats(wf_stats):
  """[sort worflow stats by most frequent]

  Args:
    wf_stats ([dict]): [dictionary of workflows keyed by id]

  Returns:
    [list]: [list of workflows sorted by most frequent]
  """
  wf_list = []
  for _, wf in wf_stats.items():
    wf_list.append((wf['name'], wf['type'], wf['workflows']))

  return sorted(wf_list, key=lambda wf: wf[2], reverse=True)

def count_items_in_tuple_list(tuple_list, ndx):
  """[count the repeat items in the workflow list and dedup the list]
  """
  # count the list
  counted_objects = []
  for items in tuple_list:
    counted_wfs = []
    for wf in items[ndx]:
      counted_wfs.append("{1}- {0}".format(wf, items[ndx].count(wf)))
      
    new_tuple = items[:ndx]
    new_tuple += tuple([list(set(counted_wfs))])
    
    counted_objects.append(new_tuple)
    
  return counted_objects

def sort_object_stats(object_list):
  """[sort workflow frequency by specific artifact, task, incident, attachment]

  Args:
    object_list ([dict]): [dictionary of object types and the workflows used within each object]

  Returns:
    [list]: [description]
  """
  sort_list = []
  for k, v in object_list.items():
    sort_list.append((k, len(v), v))

  sorted_objects = sorted(sort_list, key=lambda obj: obj[1], reverse=True)
  # count the list
  return count_items_in_tuple_list(sorted_objects, 2)

results = playbook.functions.results.workflow_data
# MAIN
if results['success']:
  msg = []
  # get all workflows grouped by incident
  for inc_id, entities in results['content']['workflow_content'].items():
    for entity in entities['entities']:
      # filter out these workflows to get content
      if "PB: Get" not in entity.get('workflow', {}).get('name'):
        update_workflow_stats(entity.get('workflow', {}).get('name'), entity.get('workflow', {}).get('workflow_id'), entity.get('object', {}).get('type_name'))
        update_object_stats(entity.get('workflow', {}).get('name'), entity.get('object', {}).get('object_name'), entity.get('object', {}).get('type_name'))

  # make tuples so we can sort
  wf_list = sort_wf_stats(wf_stats)
  msg.append("Top 10 workflows. Incidents {} to {}".format(results.inputs['pb_min_incident_id'], results.inputs['pb_max_incident_id']))
  msg.extend(["  {2}: {0} ({1})".format(wf_list[x][0], wf_list[x][1], wf_list[x][2]) for x in range(0, 10) if x < len(wf_list)])

  for obj in OBJECT_TYPES:
    msg.append("\nTop 10 workflows by {}".format(obj))
    obj_list = sort_object_stats(object_stats[obj])
    if obj_list:
      msg.extend(["  {1}: {0}\n  {2}".format(obj_list[x][0], obj_list[x][1], obj_list[x][2])  for x in range(0, 10) if x < len(obj_list)])
    else:
      msg.append("  None")

  incident.addNote(helper.createPlainText("\n".join(msg)))
else:
  incident.addNote("PB: Get workflow frequency failed: {}".format(results.reason))

```

---
## Local script - Get Playbook Data Post-Process Script

### Description


### Script Type
`Local script`

### Object Type
`incident`

### Script Content
```python
INCIDENT_URL = "<a href='/#incidents/{0}'>{0}</a>"
OBJECT_TYPES = ['incident', 'task', 'artifact', 'attachment', 'note', 'milestone']
wf_stats = {}
object_stats = { object: {} for object in OBJECT_TYPES }


def update_workflow_stats(workflow_name, workflow_id, workflow_type):
  """[tracking frequency of workflows by workflow id]

  Args:
    workflow_name ([str]): [workflow name]
    workflow_id ([int]): [id of workflow]
    workflow_type ([str]): [artifact, incident, task, or attachment]
  """
  if workflow_id not in wf_stats:
    wf_stats[workflow_id] = {
      "name": workflow_name,
      "type": workflow_type,
      "workflows": 0
    }

  wf_stats[workflow_id]['workflows'] += 1

def update_object_stats(workflow_name, object_name, object_type):
  """[track what workflows are run on a given attachment, task or artifact]

  Args:
    workflow_name ([str]): [workflow name]
    object_name ([str]): [value of artifact or name to attachment/task]
    object_type ([str]): [artifact, incident, task, or attachment]
  """
  if object_name not in object_stats.get(object_type, []):
    if object_type not in object_stats:
      object_stats[object_type] = {}
    object_stats[object_type][object_name] = []

  object_stats[object_type][object_name].append(workflow_name)

def sort_wf_stats(wf_stats):
  """[sort worflow stats by most frequent]

  Args:
    wf_stats ([dict]): [dictionary of workflows keyed by id]

  Returns:
    [list]: [list of workflows sorted by most frequent]
  """
  wf_list = []
  for _, wf in wf_stats.items():
    wf_list.append((wf['name'], wf['type'], wf['workflows']))

  return sorted(wf_list, key=lambda wf: wf[2], reverse=True)

def count_items_in_tuple_list(tuple_list, ndx):
  """[count the repeat items in the workflow list and dedup the list]
  """
  # count the list
  counted_objects = []
  for items in tuple_list:
    counted_wfs = []
    for wf in items[ndx]:
      counted_wfs.append("{1}- {0}".format(wf, items[ndx].count(wf)))
      
    new_tuple = items[:ndx]
    new_tuple += tuple([list(set(counted_wfs))])
    
    counted_objects.append(new_tuple)
    
  return counted_objects

def sort_object_stats(object_list):
  """[sort workflow frequency by specific artifact, task, incident, attachment]

  Args:
    object_list ([dict]): [dictionary of object types and the workflows used within each object]

  Returns:
    [list]: [description]
  """
  sort_list = []
  for k, v in object_list.items():
    sort_list.append((k, len(v), v))

  sorted_objects = sorted(sort_list, key=lambda obj: obj[1], reverse=True)
  # count the list
  return count_items_in_tuple_list(sorted_objects, 2)

results = playbook.functions.results.playbook_data
# MAIN
if results['success']:
  msg = []
  # get all workflows grouped by incident
  for inc_id, entities in results['content']['playbook_content'].items():
    for entity in entities:
      # filter out these workflows to get content
      if "PB: Get" not in entity.get('playbook', {}).get('display_name'):
        update_workflow_stats(entity.get('playbook', {}).get('display_name'), entity.get('playbook', {}).get('id'), entity.get('object', {}).get('type_name'))
        update_object_stats(entity.get('playbook', {}).get('display_name'), entity.get('object', {}).get('object_name'), entity.get('object', {}).get('type_name'))

  # make tuples so we can sort
  wf_list = sort_wf_stats(wf_stats)
  msg.append("Top 10 playbooks. Incidents {} to {}".format(results.inputs['pb_min_incident_id'], results.inputs['pb_max_incident_id']))
  msg.extend(["  {2}: {0} ({1})".format(wf_list[x][0], wf_list[x][1], wf_list[x][2]) for x in range(0, 10) if x < len(wf_list)])

  for obj in OBJECT_TYPES:
    msg.append("\nTop 10 playbooks by {}".format(obj))
    obj_list = sort_object_stats(object_stats[obj])
    if obj_list:
      msg.extend(["  {1}: {0}\n  {2}".format(obj_list[x][0], obj_list[x][1], obj_list[x][2])  for x in range(0, 10) if x < len(obj_list)])
    else:
      msg.append("  None")

  incident.addNote(helper.createPlainText("\n".join(msg)))
else:
  incident.addNote("PB: Get playbook frequency failed: {}".format(results.reason))

```

---

