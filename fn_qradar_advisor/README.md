<!--
  This README.md is generated by running:
  "resilient-sdk docgen -p fn_qradar_advisor"

  It is best edited using a Text Editor with a Markdown Previewer. VS Code
  is a good example. Checkout https://guides.github.com/features/mastering-markdown/
  for tips on writing with Markdown

  All fields followed by "::CHANGE_ME::"" should be manually edited

  If you make manual edits and run docgen again, a .bak file will be created

  Store any screenshots in the "doc/screenshots" directory and reference them like:
  ![screenshot: screenshot_1](./screenshots/screenshot_1.png)

  NOTE: If your app is available in the container-format only, there is no need to mention the integration server in this readme.
-->

# fn_qradar_advisor

## Table of Contents
- [Release Notes](#release-notes)
- [Overview](#overview)
  - [Key Features](#key-features)
- [Requirements](#requirements)
  - [SOAR platform](#soar-platform)
  - [Cloud Pak for Security](#cloud-pak-for-security)
  - [Proxy Server](#proxy-server)
  - [Python Environment](#python-environment)
  - [Endpoint Developed With](#endpoint-developed-with)
- [Installation](#installation)
  - [Install](#install)
  - [App Configuration](#app-configuration)
  - [Custom Layouts](#custom-layouts)
- [Function - QRadar Advisor Map Rule](#function---qradar-advisor-map-rule)
- [Function - QRadar Advisor Offense Analysis](#function---qradar-advisor-offense-analysis)
- [Function - Watson Search](#function---watson-search)
- [Function - Watson Search with Local Context](#function---watson-search-with-local-context)
- [Script - Create Artifact for QRadar Advisor Analysis Observable](#script---create-artifact-for-qradar-advisor-analysis-observable)
- [Script - Create Artifact for Watson Search with Local Context](#script---create-artifact-for-watson-search-with-local-context)
- [Data Table - QRadar Advisor analysis results](#data-table---qradar-advisor-analysis-results)
- [Data Table - Watson Search with Local Context results](#data-table---watson-search-with-local-context-results)
- [Custom Fields](#custom-fields)
- [Rules](#rules)
- [Troubleshooting & Support](#troubleshooting--support)
---

## Release Notes
<!--
  Specify all changes in this release. Do not remove the release 
  notes of a previous release
-->
| Version | Date | Notes |
| ------- | ---- | ----- |
| 2.1.0 | 9/2022 | Payload samples. |
| 2.0.2 | 9/2020 | App Host & proxy support. Updated deprecated API endpoints. |
| 2.0.1 | 2019 | Python 3 bug fix |
| 2.0.0 | 2019 | Support for 2.0  |
| 1.0.1 | 8/2018 | Watson Search fixed version compatibility with search that returns no data |
| 1.0.0 | 2018 | Initial Release |

---

## Overview
<!--
  Provide a high-level description of the function itself and its remote software or application.
  The text below is parsed from the "description" and "long_description" attributes in the setup.py file
-->
**IBM SOAR QRadar Advisor Functions**

 ![screenshot: main](./doc/screenshots/main.png) <!-- ::CHANGE_ME:: -->

The QRadar Advisor integration with IBM QRadar SOAR enables SOAR users to gather Cyber MITRE ATT&CK information from QRadar Advisor. The integration supports QRadar Advisor quick search, full search, map a rule, and retrieve offense insights and analysis.

### Key Features
<!--
  List the Key Features of the Integration
-->
* Key Feature 1 <!-- ::CHANGE_ME:: -->
* Key Feature 2 <!-- ::CHANGE_ME:: -->
* Key Feature 3 <!-- ::CHANGE_ME:: -->

---

## Requirements
<!--
  List any Requirements 
--> 
<!-- ::CHANGE_ME:: -->
This app supports the IBM Security QRadar SOAR Platform and the IBM Security QRadar SOAR for IBM Cloud Pak for Security.

### SOAR platform
The SOAR platform supports two app deployment mechanisms, App Host and integration server.

If deploying to a SOAR platform with an App Host, the requirements are:
* SOAR platform >= `44.0.7583`.
* The app is in a container-based format (available from the AppExchange as a `zip` file).

If deploying to a SOAR platform with an integration server, the requirements are:
* SOAR platform >= `44.0.7583`.
* The app is in the older integration format (available from the AppExchange as a `zip` file which contains a `tar.gz` file).
* Integration server is running `resilient_circuits>=44.0.0`.
* If using an API key account, make sure the account provides the following minimum permissions: 
  | Name | Permissions |
  | ---- | ----------- |
  | Org Data | Read |
  | Function | Read |

The following SOAR platform guides provide additional information: 
* _App Host Deployment Guide_: provides installation, configuration, and troubleshooting information, including proxy server settings. 
* _Integration Server Guide_: provides installation, configuration, and troubleshooting information, including proxy server settings.
* _System Administrator Guide_: provides the procedure to install, configure and deploy apps. 

The above guides are available on the IBM Documentation website at [ibm.biz/soar-docs](https://ibm.biz/soar-docs). On this web page, select your SOAR platform version. On the follow-on page, you can find the _App Host Deployment Guide_ or _Integration Server Guide_ by expanding **Apps** in the Table of Contents pane. The System Administrator Guide is available by expanding **System Administrator**.

### Cloud Pak for Security
If you are deploying to IBM Cloud Pak for Security, the requirements are:
* IBM Cloud Pak for Security >= 1.4.
* Cloud Pak is configured with an App Host.
* The app is in a container-based format (available from the AppExchange as a `zip` file).

The following Cloud Pak guides provide additional information: 
* _App Host Deployment Guide_: provides installation, configuration, and troubleshooting information, including proxy server settings. From the Table of Contents, select Case Management and Orchestration & Automation > **Orchestration and Automation Apps**.
* _System Administrator Guide_: provides information to install, configure, and deploy apps. From the IBM Cloud Pak for Security IBM Documentation table of contents, select Case Management and Orchestration & Automation > **System administrator**.

These guides are available on the IBM Documentation website at [ibm.biz/cp4s-docs](https://ibm.biz/cp4s-docs). From this web page, select your IBM Cloud Pak for Security version. From the version-specific IBM Documentation page, select Case Management and Orchestration & Automation.

### Proxy Server
The app **does** support a proxy server.

### Python Environment
Both Python 2.7 and Python 3.6 are supported.
Additional package dependencies may exist for each of these packages:
* resilient_circuits>=44.0.0

### Endpoint Developed With

This app has been implemented using:
| Product Name | Product Version | API URL | API Version |
| ------------ | --------------- | ------- | ----------- |
| <!-- ::CHANGE_ME:: --> | <!-- ::CHANGE_ME:: --> | <!-- ::CHANGE_ME:: --> | <!-- ::CHANGE_ME:: --> |

#### Prerequisites
<!--
List any prerequisites that are needed to use with this endpoint solution. Remove any section that is unnecessary.
-->
* Prereq A <!-- ::CHANGE_ME:: -->
* Prereq B <!-- ::CHANGE_ME:: -->
* Prereq C <!-- ::CHANGE_ME:: -->

#### Configuration
<!--
List any steps that are needed to configure the endpoint to use this app.
-->
* Config A <!-- ::CHANGE_ME:: -->
* Config B <!-- ::CHANGE_ME:: -->
* Config C <!-- ::CHANGE_ME:: -->

#### Permissions
<!--
List any user permissions that are needed to use this endpoint. For example, list the API key permissions.
-->
* Permission A <!-- ::CHANGE_ME:: -->
* Permission B <!-- ::CHANGE_ME:: -->
* Permission C <!-- ::CHANGE_ME:: -->


---

## Installation

### Install
* To install or uninstall an App or Integration on the _SOAR platform_, see the documentation at [ibm.biz/soar-docs](https://ibm.biz/soar-docs).
* To install or uninstall an App on _IBM Cloud Pak for Security_, see the documentation at [ibm.biz/cp4s-docs](https://ibm.biz/cp4s-docs) and follow the instructions above to navigate to Orchestration and Automation.

### App Configuration
The following table provides the settings you need to configure the app. These settings are made in the app.config file. See the documentation discussed in the Requirements section for the procedure.

| Config | Required | Example | Description |
| ------ | :------: | ------- | ----------- |
| **qradar_advisor_app_id** | Yes | `` | *App ID from the QRadar server.* |
| **qradar_advisor_token** | Yes | `` | *QRadar Advisor token.* |
| **qradar_cafm_app_id** | Yes | `` | *Cyber Adversary Framwork Mapping App Id.* |
| **qradar_cafm_token** | Yes | `` | *Cyber Adversary Framwork Mapping token.* |
| **qradar_host** | Yes | `myhost` | *QRadar host.* |
| **full_search_timeout** | No | `1200` | *Full search timeout in seconds.* |
| **full_search_period** | No | `5` | *Full search period in seconds.* |
| **verify_cert** | Yes | `` | *<Path to certificate file> or false. * |

qradar_host=qradar_host
qradar_advisor_token=qradar_advisor_token_keyring_protection_recommended
qradar_advisor_app_id=app_id_from_qradar_server
verify_cert=[true, false] for verify https certificate or not
full_search_timeout=optional_full_search_timeout_in_seconds_default_1200
full_search_period=optional_full_search_period_in_seconds_default_5
offense_analysis_timeout=optional_offense_analysis_timeout_in_seconds_default_1200
offense_analysis_period=optional_offense_analysis_period_in_seconds_default_5
### Custom Layouts
<!--
  Use this section to provide guidance on where the user should add any custom fields and data tables.
  You may wish to recommend a new incident tab.
  You should save a screenshot "custom_layouts.png" in the doc/screenshots directory and reference it here
-->
* Import the Data Tables and Custom Fields like the screenshot below:

  ![screenshot: custom_layouts](./doc/screenshots/custom_layouts.png) <!-- ::CHANGE_ME:: -->


---

## Function - QRadar Advisor Map Rule
Map rule to MITRE ATT&CK tactic

 ![screenshot: fn-qradar-advisor-map-rule ](./doc/screenshots/fn-qradar-advisor-map-rule.png) <!-- ::CHANGE_ME:: -->

<details><summary>Inputs:</summary>
<p>

| Name | Type | Required | Example | Tooltip |
| ---- | :--: | :------: | ------- | ------- |
| `qradar_rule_name` | `text` | No | `-` | Name of QRadar rule |

</p>
</details>

<details><summary>Outputs:</summary>
<p>

> **NOTE:** This example might be in JSON format, but `results` is a Python Dictionary on the SOAR platform.

<!-- ::CHANGE_ME:: -->
```python
results = {
    # TODO: Generate an example of the Function Output within this code block.
    # To get the output of a Function:
    #   1. Run resilient-circuits in DEBUG mode: $ resilient-circuits run --loglevel=DEBUG
    #   2. Invoke the Function in SOAR
    #   3. Gather the results using: $ resilient-sdk codegen -p fn_qradar_advisor --gather-results
    #   4. Run docgen again: $ resilient-sdk docgen -p fn_qradar_advisor
} 
```

</p>
</details>

<details><summary>Example Pre-Process Script:</summary>
<p>

```python
inputs.qradar_rule_name = incident.properties.qradar_rule
```

</p>
</details>

<details><summary>Example Post-Process Script:</summary>
<p>

```python
tactics = results.tactics
mapping = tactics["mapping"]
att_tactics = ", ".join(mapping.keys())
incident.properties.mitre_tactic_name = att_tactics

```

</p>
</details>

---
## Function - QRadar Advisor Offense Analysis
Given a Resilient artifact, this function performs a QRadar Advisor analysis and returns Local, Watson enriched, or Expanded local context (default) results.

 ![screenshot: fn-qradar-advisor-offense-analysis ](./doc/screenshots/fn-qradar-advisor-offense-analysis.png) <!-- ::CHANGE_ME:: -->

<details><summary>Inputs:</summary>
<p>

| Name | Type | Required | Example | Tooltip |
| ---- | :--: | :------: | ------- | ------- |
| `qradar_advisor_result_stage` | `select` | No | `-` | stage1(Local), stage2(Watson enriched), stage3(Expanded local context) |
| `qradar_analysis_restart_if_existed` | `boolean` | No | `-` | restart the analysis if there is an existing result |
| `qradar_offense_id` | `text` | No | `-` | QRadar Offense ID |

</p>
</details>

<details><summary>Outputs:</summary>
<p>

> **NOTE:** This example might be in JSON format, but `results` is a Python Dictionary on the SOAR platform.

<!-- ::CHANGE_ME:: -->
```python
results = {
    # TODO: Generate an example of the Function Output within this code block.
    # To get the output of a Function:
    #   1. Run resilient-circuits in DEBUG mode: $ resilient-circuits run --loglevel=DEBUG
    #   2. Invoke the Function in SOAR
    #   3. Gather the results using: $ resilient-sdk codegen -p fn_qradar_advisor --gather-results
    #   4. Run docgen again: $ resilient-sdk docgen -p fn_qradar_advisor
} 
```

</p>
</details>

<details><summary>Example Pre-Process Script:</summary>
<p>

```python
#
# This sample workflow uses the custom field (qradar_id) to perform 
# an offense analysis in QRadar Advisor
#
inputs.qradar_offense_id = incident.properties.qradar_id
```

</p>
</details>

<details><summary>Example Post-Process Script:</summary>
<p>

```python
#
# Result retured by the QRadar Advisor Offense Analysis function:
#   * results.observables: observables and their details, used here to be output to Data table.
#   * results.note: html representation of STIX data, used here to generate a Note.
#   * results.insights: used here to create a Task.
#   * results.stix: raw stix data, preserved for any customized parsing.
#
#   Note: results.insights can be a status code e.g. 404
#
# We publish a data table according to the stix

# Check that we didn't get a status of 404 (no observables) for insights.
if "status_code" in results["insights"] and results["insights"]["status_code"] == 404:
    process_insights = False
else:
    process_insights = True

for observable in results.observables:
  qradar_obs = incident.addRow("qradar_advisor_observable")
  qradar_obs.qradar_advisor_toxicity = observable.toxicity
  qradar_obs.qradar_advisor_relevance = observable.relevance
  qradar_obs.qradar_advisor_type = observable.type
  qradar_obs.qradar_advisor_description = observable.description

# Pass insights data (with MITRE ATTACK tactics information) to following function
# using workflow.properties.qraw_offense_insights. Refer to the Output tab please

# Our STIX tree or error status.
html = helper.createRichText(results.note)
incident.addNote(html)

if process_insights:
    # If we didn't get a 404 (no observables) status process for insights.
    # Task
    task_title = "Review QRadar Advisor Analysis for Offense " + str(incident.properties.qradar_id)
    task_summary = results.insights.insights + "\n\n" + results.insights.stage3_insights
    incident.addTask(task_title, "Initial", task_summary)

    #
    # MITRE tactic information
    #
    tactics = results.insights["tactics"]

    mitre_tactic_names = []
    if tactics is not None:
      for tactic in tactics:
        #
        # Note, even though QRAW calls it tactic_id, it is more a tactic name
        #
        mitre_tactic_names.append(tactic["tactic_id"])
    #
    # QRadar Advisor might return more than one tactics for a given offense. Include them inputs
    # a comma separated string
    #
    incident.properties.mitre_tactic_name = ", ".join(mitre_tactic_names)

# Note that results.stix is the raw stix return from QRadar Advisor in stix 2 (json) format
# Users can add their customize codes to handle the stix data here
#
```

</p>
</details>

---
## Function - Watson Search
Given a Resilient artifact, this function performs a Watson Search (a QRadar Advisor quick search) and returns a summary.

 ![screenshot: fn-watson-search ](./doc/screenshots/fn-watson-search.png) <!-- ::CHANGE_ME:: -->

<details><summary>Inputs:</summary>
<p>

| Name | Type | Required | Example | Tooltip |
| ---- | :--: | :------: | ------- | ------- |
| `qradar_advisor_search_value` | `text` | No | `-` | indicator to search, types include Domain Name, IP Address, hashes, URL, or user name. |

</p>
</details>

<details><summary>Outputs:</summary>
<p>

> **NOTE:** This example might be in JSON format, but `results` is a Python Dictionary on the SOAR platform.

<!-- ::CHANGE_ME:: -->
```python
results = {
    # TODO: Generate an example of the Function Output within this code block.
    # To get the output of a Function:
    #   1. Run resilient-circuits in DEBUG mode: $ resilient-circuits run --loglevel=DEBUG
    #   2. Invoke the Function in SOAR
    #   3. Gather the results using: $ resilient-sdk codegen -p fn_qradar_advisor --gather-results
    #   4. Run docgen again: $ resilient-sdk docgen -p fn_qradar_advisor
} 
```

</p>
</details>

<details><summary>Example Pre-Process Script:</summary>
<p>

```python
value = artifact.value
type = artifact.type

#
# Watson Search only supports 5 indicator types: IP Address, Hash, Domain, URL, Username. 
# The “user:” prefix needs to be added to a username search
#
mapping = {
  "User Account":"user:"       
}
prefix = ""
if type in mapping:
  prefix = mapping[type]

inputs.qradar_advisor_search_value = prefix + value
```

</p>
</details>

<details><summary>Example Post-Process Script:</summary>
<p>

```python
#
# Return data in this example
#   results.search_results.suspicious_observables:
#     Suspicious observables related to this indicator. Used in the post-process script to create artifacts,
#     if the type of the observable can be mapped to an default artifact type.
#
#  Note: results.return_search can have status code e.g. 422
#
return_search = results.search

status_set = True if "status_code" in return_search else False
if not status_set:
    api_version = 2 if "suspicious_observables" in return_search.search_results else 1

#
# Sample return json dict for v2.0
#
'''{
      "search": {
          "search_value_type": "DomainName", 
          "other_count": 1, 
          "search_results": {
          "suspicious_observables": [
                  {
                      "reference_count": 1, 
                      "timestamp": 1529421998, 
                      "type": "DomainName", 
                      "label": "mydomain.com"
                  }, 
                  {
                      "reference_count": 1, 
                      "timestamp": 1462407300, 
                      "type": "EmailContent", 
                      "label": "ccf2d5f4ab37650ccbb582f351aa6fdd:"
                  }, 
                  {
                      "reference_count": 1, 
                      "timestamp": 1462407300, 
                      "type": "File", 
                      "label": "ccf2d5f4ab37650ccbb582f351aa6fdd"
                  }, 
                  {
                      "reference_count": 1, 
                      "timestamp": 1463566500, 
                      "type": "IpAddress", 
                      "label": "190.104.198.116"
                  },
                  {
                      "reference_count": 1, 
                      "timestamp": 1463072400, 
                      "type": "Hash", 
                      "label": "51417677b5e7b17542d383f5b25e2b43"
                  }
          ], 
          "other_observables": [
              {
                  "reference_count": 1, 
                  "timestamp": 1529421998, 
                  "type": "DomainName", 
                  "label": "mydomain.com"
              }
          ]
      }, 
      "suspicious_count": 5, 
      "search_value": "mydomain.com", 
      "reference_count": 1, 
      "is_toxic": false}, 
      "whois": {
          "updated_date": "2015-09-15T23:25:25.000Z", 
          "contact_country": "Canada", 
          "registrar_name": "Domain.com, LLC", 
          "contact_email": "noreply@data-protected.net", 
          "created_date": "2000-06-22T04:00:00.000Z", 
          "contact_name": "Data Protected Data Protected", 
          "contact_type": "registrant", "contact_org": "Data Protected"
      }
      }
'''
#
# We ONLY create artifacts for those observables that can be mapped to
# default Resilient artifacts. If customer has custom artifacts, and wants
# to map them as well, please modify the following mapping dict.
#
mapping = {
    "DomainName": "DNS Name",
    "EmailContent": "Email Body",
    "File": "Malware MD5 Hash",  # File type is a hash value. So we map File to Malware MD5 Hash
    "IpAddress": "IP Address",
    "Hash": {
        32: "Malware MD5 Hash",
        40: "Malware SHA-1 Hash",
        64: "Malware SHA-256 Hash"
    }
}

#
# Note that in this example workflow, we only extract the suspicious_observables
#
if status_set:
    # Add an error status note.
    summary_string = 'The artifact returned an error.'
    status_string = "QRadar Advisor returned status code '{}'.".format(return_search["status_code"])
    if return_search["status_code"] == 422:
        summary_string = "This artifact has an unsupported value."

    note_string = "<h3>Watson Search Result Summary</h3><hr>"
    note_string += "<br><p><span style=\"font-weight:bold\">" + status_string + "</span></p>"
    note_string += "<p><span style=\"font-weight:bold\">" + summary_string + "</span></p><br>"
    note_string +=  "<p>Search Value: " + return_search.search_value + "</p>"
    note_string +=  "<p>Search Type:  <span style=\"color:white; border-bottom-left-radius: 2.96667px;background-color:#808080\">&nbsp " + artifact.type + "&nbsp</span></p>"
    html_note = helper.createRichText(note_string)
    incident.addNote(html_note)

elif api_version == 2:
    # v2.0
    suspicious_observables = return_search.search_results.suspicious_observables

    new_artifact_count = 0
    summary_string = "This artifact is not a suspicious observable"

    for observable in suspicious_observables:
        #
        # We support only those defined in mapping dict above
        #
        if observable.type in mapping:
            #
            # Note sometimes QRadar Advisor return the artifact itself as a suspicious observable. We don't want to
            # duplicate here.
            #
            if mapping[observable.type] != artifact.type or observable.label != artifact.value:
                new_artifact_count += 1
                if observable.type == "Hash":
                    if len(observable.label) in mapping[observable.type] and  observable.label.isalnum():
                        # Hash is likely MD5, SHA1 or SHA256.
                        incident.addArtifact(mapping[observable.type][len(observable.label)], observable.label,
                                             "Watson Search result")
                else:
                    incident.addArtifact(mapping[observable.type], observable.label, "Watson Search result")
            else:
                #
                # The artifact itself is a suspicious observable. We don't create new (duplicated) artifact. But we show this info
                #
                summary_string = "This artifact is a suspicious observable"

    # Add a note about number of suspicious_observables
    note_string = "<h3>Watson Search Result Summary</h3><hr>"
    note_string = note_string + "<br><p><span style=\"font-weight:bold\">" + summary_string + "</span></p><br>"
    note_string = note_string + "<p>Search Value: " + return_search.search_value + "</p>"
    note_string = note_string + "<p>Search Type:  <span style=\"color:white; border-bottom-left-radius: 2.96667px;background-color:#808080\">&nbsp " + return_search.search_value_type + "&nbsp</span></p>"
    note_string = note_string + "<p style=\"color:#FF00FF;\">Suspicious observables: " + str(
        return_search.suspicious_count) + "</p>"
    note_string = note_string + "<p style=\"color:red;\">New artifacts mapped from suspicious observables: " + str(
        new_artifact_count) + "</p>"
    note_string = note_string + "<p>Other observables: " + str(return_search.other_count) + "</p>"
    html_note = helper.createRichText(note_string)
    incident.addNote(html_note)

else:
    # v1.0?
    new_artifact_count = 0
    toxic_count = 0
    non_toxic_count = 0
    summary_string = "This artifact is not a suspicious observable"
    for result in return_search.search_results:
        value_type = result["type"]
        if value_type in mapping:
            #
            # We know what artifact type corresponds to this value type
            #
            for val in result["values"]:
                #
                # We care about the toxic ones only
                #
                if val["is_toxic"]:
                    toxic_count += 1
                    #
                    # Note sometimes QRadar Advisor return the artifact itself as a suspicious observable. We don't want to
                    # duplicate here.
                    #
                    if mapping[value_type] != artifact.type or val.label != artifact.value:
                        new_artifact_count += 1
                        if value_type == "Hash":
                            if len(val.label) in mapping[value_type] and  val.label.isalnum():
                                # Hash is likely MD5, SHA1 or SHA256.
                                incident.addArtifact(mapping[value_type][len(val.label)], val.label, "Watson Search result")
                        else:
                            incident.addArtifact(mapping[value_type], val.label, "Watson Search result")
                    else:
                        #
                        # The artifact itself is a suspicious observable. We don't create new (duplicated) artifact. But we show this info
                        #
                        summary_string = "This artifact is a suspicious observable"
                else:
                    non_toxic_count += 1

    # Add a note about number of suspicious_observables
    note_string = "<h3>Watson Search Result Summary</h3><hr>"
    note_string = note_string + "<br><p><span style=\"font-weight:bold\">" + summary_string + "</span></p><br>"
    note_string = note_string + "<p>Search Value: " + return_search.search_value + "</p>"
    note_string = note_string + "<p>Search Type:  <span style=\"color:white; border-bottom-left-radius: 2.96667px;background-color:#808080\">&nbsp " + return_search.search_value_type + "&nbsp</span></p>"
    note_string = note_string + "<p style=\"color:#FF00FF;\">Toxic observables: " + str(toxic_count) + "</p>"
    note_string = note_string + "<p style=\"color:red;\">New artifacts mapped from toxic observables: " + str(
        new_artifact_count) + "</p>"
    note_string = note_string + "<p>Non toxic observables: " + str(non_toxic_count) + "</p>"
    html_note = helper.createRichText(note_string)
    incident.addNote(html_note)



```

</p>
</details>

---
## Function - Watson Search with Local Context
Given a Resilient artifact, this function performs a Watson Search with Local Context (a QRadar Advisor full search) and returns Local, Watson enriched, or Expanded local context (default) results.

 ![screenshot: fn-watson-search-with-local-context ](./doc/screenshots/fn-watson-search-with-local-context.png) <!-- ::CHANGE_ME:: -->

<details><summary>Inputs:</summary>
<p>

| Name | Type | Required | Example | Tooltip |
| ---- | :--: | :------: | ------- | ------- |
| `qradar_advisor_result_stage` | `select` | No | `-` | stage1(Local), stage2(Watson enriched), stage3(Expanded local context) |
| `qradar_advisor_search_value` | `text` | No | `-` | indicator to search, types include Domain Name, IP Address, hashes, URL, or user name. |

</p>
</details>

<details><summary>Outputs:</summary>
<p>

> **NOTE:** This example might be in JSON format, but `results` is a Python Dictionary on the SOAR platform.

<!-- ::CHANGE_ME:: -->
```python
results = {
    # TODO: Generate an example of the Function Output within this code block.
    # To get the output of a Function:
    #   1. Run resilient-circuits in DEBUG mode: $ resilient-circuits run --loglevel=DEBUG
    #   2. Invoke the Function in SOAR
    #   3. Gather the results using: $ resilient-sdk codegen -p fn_qradar_advisor --gather-results
    #   4. Run docgen again: $ resilient-sdk docgen -p fn_qradar_advisor
} 
```

</p>
</details>

<details><summary>Example Pre-Process Script:</summary>
<p>

```python
value = artifact.value
type = artifact.type

#
# Watso Search with Local Context only supports 5 indicator types: IP Address, Hash, DomainName, URL, Username. 
# The “user:” prefix needs to be added to a username search.
#
mapping = {
  "User Account":"user:"       
}
prefix = ""
if type in mapping:
  prefix = mapping[type]

inputs.qradar_advisor_search_value = prefix + value
```

</p>
</details>

<details><summary>Example Post-Process Script:</summary>
<p>

```python
import java.util.Date as Date

# Return data of function Watson Search with Local Context:
#   * results.observables: observables and their details, used here to be output to Data table.
#   * results.note: html representation of STIX data, used here to generate a Note.
#   * results.summary: used here to create a Task.
#   * results.stix: raw stix data (not used here), for any customized parsing.

# Check that we didn't get a status of 404 (no observables) for insights.
if "status_code" in results["stix"] and results["stix"]["status_code"] == 404:
    add_task = False
else:
    add_task  = True
# We publish a data table according to the stix if obserables found.
date_str = str(Date())
for observable in results.observables:
  qradar_obs = incident.addRow("qradar_advisor_observable_for_artifact")
  qradar_obs.qradar_advisor_toxicity = observable.toxicity 
  qradar_obs.qradar_advisor_relevance = observable.relevance
  qradar_obs.qradar_advisor_type = observable.type 
  qradar_obs.qradar_advisor_description = observable.description 
  qradar_obs.artifact_related = artifact.value
  qradar_obs.full_search_time = date_str
# Our STIX tree or error message
html = helper.createRichText(results.note)
incident.addNote(html)

if add_task:
    # Create a task
    incident.addTask("Review Watson Search with Local Context of artifact: " + artifact.value, "Initial", results.summary)
```

</p>
</details>

---

## Script - Create Artifact for QRadar Advisor Analysis Observable
Create an artifact for the selected observable.

**Object:** qradar_advisor_observable

<details><summary>Script Text:</summary>
<p>

```python
#
# We create artifacts for those observables according to how they can be mapped to 
# Resilient default artifacts. If user has custom artifacts, and wants
# to map them as well, please modify the following mapping dict. 
#
# All the other observables without direct mapping, try to make decision depending
# on the qradar_advisor_description of them. If not decision can be made, then 
# a String type artifact will be created.
#
mapping = {
    "domain-name": "DNS Name",
    "domain": "DNS Name",
    "EmailContent": "Email Body",
    "ipv4-addr": "IP Address",
    "malware": "Malware Family/Variant",
    "url": "URL",
    "identity": "User Account"
}

artifact_description = "QRadar Advisor Analysis observable"
type = row.qradar_advisor_type
if type in mapping:
    incident.addArtifact(mapping[type], row.qradar_advisor_description, artifact_description)
else:
    artifact_type = "String"
    #
    # if the type is "file", the description could be MD5 hash, SHA-256 hash, SHA-1.
    # Distinguish them according to the length.
    #
    # Anything else is considered "File Name"
    #
    if type == "file":
        if len(row.qradar_advisor_description) == 32:
            artifact_type = "Malware MD5 Hash"
        elif len(row.qradar_advisor_description) == 64:
            artifact_type = "Malware SHA-256 Hash"
        elif len(row.qradar_advisor_description) == 40:
            artifact_type = "Malware SHA-1 Hash"
        else:
            artifact_type = "File Name"

    incident.addArtifact(artifact_type, row.qradar_advisor_description, artifact_description)
```

</p>
</details>

---
## Script - Create Artifact for Watson Search with Local Context
Create an artifact for the selected row

**Object:** qradar_advisor_observable_for_artifact

<details><summary>Script Text:</summary>
<p>

```python
#
# We create artifacts for those observables according to how they can be mapped to
# Resilient default artifacts. If user has custom artifacts, and wants
# to map them as well, please modify the following mapping dict.
#
# All the other observables without direct mapping, try to make decision depending
# on the qradar_advisor_description of them. If not decision can be made, then
# a String type artifact will be created.
#
mapping = {
    "domain-name": "DNS Name",
    "domain": "DNS Name",
    "EmailContent": "Email Body",
    "ipv4-addr": "IP Address",
    "malware": "Malware Family/Variant",
    "url": "URL",
    "identity": "User Account"
}

artifact_description = "Watson Search with Local Context observable"
type = row.qradar_advisor_type
if type in mapping:
    incident.addArtifact(mapping[type], row.qradar_advisor_description, artifact_description)
else:
    artifact_type = "String"
    #
    # if the type is "file", the description could be MD5 hash, SHA-256 hash, SHA-1.
    # Distinguish them according to the length.
    #
    # Anything else is considered "File Name"
    #
    if type == "file":
        if len(row.qradar_advisor_description) == 32:
            artifact_type = "Malware MD5 Hash"
        elif len(row.qradar_advisor_description) == 64:
            artifact_type = "Malware SHA-256 Hash"
        elif len(row.qradar_advisor_description) == 40:
            artifact_type = "Malware SHA-1 Hash"
        else:
            artifact_type = "File Name"

    incident.addArtifact(artifact_type, row.qradar_advisor_description, artifact_description)
```

</p>
</details>

---

## Data Table - QRadar Advisor analysis results

 ![screenshot: dt-qradar-advisor-analysis-results](./doc/screenshots/dt-qradar-advisor-analysis-results.png) <!-- ::CHANGE_ME:: -->

#### API Name:
qradar_advisor_observable

#### Columns:
| Column Name | API Access Name | Type | Tooltip |
| ----------- | --------------- | ---- | ------- |
| Description | `qradar_advisor_description` | `text` | observable description |
| Relevance | `qradar_advisor_relevance` | `text` | x_ibm_security_relevance from QRadar Advisor return |
| Toxicity | `qradar_advisor_toxicity` | `text` | x_ibm_security_toxicity from QRadar Advisor return |
| Type | `qradar_advisor_type` | `text` | observable type |

---
## Data Table - Watson Search with Local Context results

 ![screenshot: dt-watson-search-with-local-context-results](./doc/screenshots/dt-watson-search-with-local-context-results.png) <!-- ::CHANGE_ME:: -->

#### API Name:
qradar_advisor_observable_for_artifact

#### Columns:
| Column Name | API Access Name | Type | Tooltip |
| ----------- | --------------- | ---- | ------- |
| Artifact Searched | `artifact_related` | `text` | artifact used to perform the Watson Search with Local Context |
| Description | `qradar_advisor_description` | `text` | observerable description |
| Relevance | `qradar_advisor_relevance` | `text` | x_ibm_security_relevance from QRadar Advisor return |
| Search Time | `full_search_time` | `text` | time when search performed |
| Toxicity | `qradar_advisor_toxicity` | `text` | x_ibm_security_toxicity from QRadar Advisor return |
| Type | `qradar_advisor_type` | `text` | observable type |

---

## Custom Fields
| Label | API Access Name | Type | Prefix | Placeholder | Tooltip |
| ----- | --------------- | ---- | ------ | ----------- | ------- |
| MITRE ATT&CK Tactic name | `mitre_tactic_name` | `text` | `properties` | MITRE tactic name | MITRE ATT&CK Tactic name |
| qradar_id | `qradar_id` | `text` | `properties` | - | - |
| qradar_rule | `qradar_rule` | `text` | `properties` | - | Name of a QRadar rule |

---


## Rules
| Rule Name | Object | Workflow Triggered |
| --------- | ------ | ------------------ |
| Create Artifact (QRadar Advisor Analysis) | qradar_advisor_observable | `-` |
| Create Artifact (Watson Search with Local Context) | qradar_advisor_observable_for_artifact | `-` |
| Map QRadar rule | incident | `qradar_advisor_map_rule` |
| QRadar Advisor Offense Analysis | incident | `qradar_advisor_offense_analysis` |
| Watson Search | artifact | `qradar_advisor_quick_search` |
| Watson Search with Local Context | artifact | `qradar_advisor_full_search` |

---


## Troubleshooting & Support
Refer to the documentation listed in the Requirements section for troubleshooting information.

### For Support
This is an IBM supported app. Please search [ibm.com/mysupport](https://ibm.com/mysupport) for assistance.
